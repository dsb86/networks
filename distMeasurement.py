# Written By Daniel Brotman dsb86@case.du
# Socket syntax adapted heavily from:
# https://blogs.oracle.com/ksplice/entry/learning_by_doing_writing_your


import socket
import struct
from timeit import default_timer

# Random unlikely udp port
local_port = 18675

# Open file containing ip list
f= open("targets.txt", 'r')

# Run through list of ip addresses
for c in range (0, 10, 1):
    # Read ip line by line
    dest_ip = f.readline()

    # Cut separation characters from string
    cut = len(dest_ip)-1
    dest_ip = dest_ip[0:cut]

    # Maximum datagram generated by lipsum.com for 1472 byte payload (1500mtl -20ip -8udp)
    data = r'Lor dolor sit amet, consectetur adipiscing elit.Pellentesque id velit interdum, semper ex id, molestie augue. Aenean vel viverra libero. Integer pharetra enim ipsum, vel feugiat turpis vulputate sit amet. Curabitur non risus nec ante luctus feugiat. Vivamus ac sapien sed lacus venenatis interdum. Nulla pellentesque ultrices massa vitae hendrerit. Proin sit amet porta odio, id blandit magna. Vivamus eget laoreet purus. Proin eu ipsum tellus. Pellentesque quis metus sit amet augue lobortis congue at sed sapien. Vestibulum vel purus ut risus semper cursus aliquam at lacus. Vivamus vitae tellus aliquet, interdum massa vel, hendrerit mauris. Morbi enim massa, aliquam ut nulla eleifend, fermentum scelerisque eros. Mauris suscipit ex sapien, a luctus ex aliquam quis. Ut pulvinar mauris ac mi finibus tempor. Mauris a eleifend lacus. Integer eu velit et lacus tincidunt pharetra non a justo. Nullam fringilla tellus sapien, et consectetur lorem bibendum at. Maecenas facilisis vehicula mi ac tempus. Duis sed dui ac sem sodales fringilla. Nunc magna nibh, maximus at augue vel, consequat cursus erat. Praesent sit amet risus nec sem dignissim sollicitudin imperdiet eu turpis. In at urna et lectus porttitor malesuada. Vivamus a congue augue, ac pellentesque ex.Praesent eu pulvinar tortor. Nunc egestas lacinia dolor eget feugiat. Interdum et malesuada fames ac ante ipsum primis in faucibus. Proin ut cursus mi. Nulla nec feugiat nisl. Etiam ut eleifend urna. Donec i'

    # Get protocols for sockets
    icmp = socket.getprotobyname('icmp')
    udp = socket.getprotobyname('udp')

    # Set max ttl
    ttl = 32

    # create receiving socket for icmp messages
    recv_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp)
    # create outgoing socket to send udp requests
    send_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, udp)

    # modify outgoing socket to use desired ttl
    send_socket.setsockopt(socket.SOL_IP, socket.IP_TTL, ttl)

    # bind receiving socket to local port
    recv_socket.bind(("", local_port))

    # send datagram
    send_socket.sendto(data, (dest_ip, local_port))

    # create variables for incoming data
    data_str = None
    data_addr = None

    # Build the GNU timeval struct (seconds, microseconds)
    timeout = struct.pack("ll", 5, 0)

    # Timeout for no reply
    recv_socket.setsockopt(socket.SOL_SOCKET, socket.SO_RCVTIMEO, timeout)

    try:

        # Start timer for rtt
        start = default_timer()

        # Send datagram
        send_socket.sendto(data, (dest_ip, local_port))

        #Listen on port
        data_str, data_addr = recv_socket.recvfrom(4096)

        # End timer and calculate rtt
        finish = default_timer()
        rtt = finish - start

        # Parse ICMP message
        # NOTE: Parsing code adapted from Austin Feydt apf31@case.edu
        final_ttl, protocol = struct.unpack("!xxxxxxxxBBxxxxxxxxxx", data_str[28:48])
        print "Hops: ", ttl - int(final_ttl)
        icmp_length = struct.unpack("!xxH", data_str[0:4])
        print "Bytes returned:", icmp_length[0] - 28
        print "rtt: ", rtt
    except socket.error:
        # catch error and print fatal ip
        print("No Response: ", dest_ip)
        pass
    finally:
        # close sockets
        send_socket.close()
        recv_socket.close()



